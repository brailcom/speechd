<chapter>
  <title>Implementation</title>
  
  <sect1><title>Server Side</title>

    <para>
    </para>

    <sect2><title>Public API for shared library</title>
       <variablelist>
           <varlistentry>
	      <term>
                int rbd_init(char* client_name, char* conn_name);
	      </term>
              <listitem>
                <para>
           Initiates new Robod session.
           Returns connection socket number or 0 if some error occured.
                </para>
               </listitem>
             </varlistentry>
       </variablelist>
   </sect2>
																	  

    <sect2 id="ssip_commands"><title>SSIP Commands</title>
      <para>
      </para>
    </sect2>

    <sect2 id="shared_library_api"><title>Public API for shared library</title>
      <sect3><title>Basic functions</title>
        <variablelist>
          <varlistentry>
            <term> int rbd_init(char* client_name, char* conn_name); </term>
             <listitem>
            <para>
             Initiates new Robod session.
             Returns connection socket number or 0 if some error occured.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> void rbd_close(int fd); </term>
             <listitem>
            <para>
             Closes active rbd session.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int rbd_get_client_id(int fd); </term>
             <listitem>
            <para>
             Returns id of client on the given fd or 0 if
             nobody is connected on this fd.
            </para>
            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

      <sect3><title>Message manipulation functions</title>
        <variablelist>
          <varlistentry>
            <term> int rbd_say(int fd, int priority, char* text); </term>
             <listitem>
            <para>
              Robod receives given text and says it
              as soon as possible according to it's priority.
              On success, it returns 1, otherwise 0.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int rbd_sayf(int fd, int priority, char *text, ...) </term>
             <listitem>
            <para>
             Same as rbd_say() but the input text can
             be formated with the same technique as printf
             uses. (in fact, it calls printf internally).
             On success, it returns 1, otherwise 0.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int rbd_stop(int fd); </term>
             <listitem>
            <para>
              Stops speaking and cancels all queued messages for
              client on socket fd.
              Returns 1 on succes, 0 if there is no client on fd.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int rbd_pause(int fd); </term>
             <listitem>
            <para>
             Pauses messages from client connected on given fd. 
             This means that it *cancels* currently spoken message
             and *waits* with all others queued or received messages
             until rbd_resume(fd) is called.  Returns 1 on succes,
             0 if there is no client on fd.
            </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term> int rbd_resume(int fd); </term>
             <listitem>
            <para>
             Unpauses paused messages. Robod will continue
             saying them according to their priority.
             Returns 1 on succes, 0 if there is no client on fd.
            </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>

      <sect3><title>Speech synthesis parameters</title>
        <variablelist>
          <varlistentry>
            <term> int set_language(char* language); </term>
             <listitem>
            <para>

            </para>
            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

      <sect3><title>History functions</title>
        <variablelist>
          <varlistentry>
            <term> int rbd_history_get_client_list(char **client_list, int **id, int *num); </term>
            <listitem>
            <para>
             This command retrieves list off all active and inactive
             clients that are present in the history tree. You can
             imagine these clients as branches of the tree in which
             we have stored lists of messages. There is stored an array
             of strings with names of each client in client_list adress,
             array of all corresponding id's of these clients and
             the number of records in these arrays.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int rbd_history_get_last(int fd, int *id, time_t *time, int *client_id); </term>
            <listitem>
            <para>
             Finds the last message spoken (acording to time)
             and gives it's ID, time and client identificator.
             It returns 1 on succes, 0 if there are no messages
             in history list.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
             int rbd_history_cursor_set_pos(int fd, int pos); 
             int rbd_history_cursor_set_first(int fd); 
             int rbd_history_cursor_set_last(int fd); 
             int rbd_history_cursor_next(int fd); 
             int rbd_history_cursor_prev(int fd);
            </term>
            <listitem>
            <para>
             This is a family of commands that provide a simple interface
             for browsing through messages in history. Client can set
             cursor to some place, move it forward and backward and
             get the message that the cursor is pointing on. Each one
             of them returns the position the cursor is set to or
             0 if the command fails (eg. position out of range).
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int rbd_history_cursor_get(int fd, int *id, time_t *time); </term>
             <listitem>
            <para>
             This command simply retrieves ID and time of the message
             the cursor is pointing on. It returns 1 on succes, 0 if
             (TODO: Is there such situation when this could happen?).
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int rbd_history_say_id(int fd, int id); </term>
             <listitem>
            <para>

             Says message from history that belongs to the client
             the cursor is pointing on and has this given id.
             It returns 1 on succes, 0 if there is no such message.

            </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term> int rbd_history_say_text(int fd, char *text); </term>
             <listitem>
            <para>
             Says unspecified text that is not intended to be put
             in history again. This happens for history (we don't
             want to have history of history) but maybe there are
             other uses. It returns 1 on succes,
             0 if there is some error (TODO: What errors?).
            </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>


    </sect2> 

    <sect2><title>Configuration</title>

      <para>
	We use DotConf libray for loading the configuration files.
      </para>

    </sect2>
    
    <sect2><title>Output Modules</title>
      
      <para>
      </para>

    </sect2>
    
  </sect1>
  
  <sect1><title>Client Side</title>
    
    <para>
    </para>
    
  </sect1>
  
</chapter>
